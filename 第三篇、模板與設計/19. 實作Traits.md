template可以將型別參數化，而如果可以引進更多的template parameter，就可以為更多的面向進行客製化，不過如同我們不喜歡function有太多需要自行傳入的參數(對使用者來說是個負擔)一樣，使用者也不喜歡自己要定義太多的template parameter。

不過，如同函式可以使用預設引數，當使用者沒有定義時，會自動定義好這些預設引數，這些參數不會造成使用者的負擔，template也可以設定預設template parameter，可使用少數的template parameter就可以定義其餘的template parameter。

特徵萃取(traits)或是traits templates是一種C++編程裝置，很大程度的加強對於參數的管理，並且還可以適用在非template parameter的型別，本章會展示出traits有用之處並示範各種技巧。

以下內容的traits通常都會出現在STL中，所以實用性是無庸置疑的，但有時為了不要影響理解，會省略一些不重要的細節。

# 19.1 範例：求序列和
此節會實作求解序列中所有數值和的功能

## 19.1.1 Fixed Traits(固定式特徵)
假設數值都放在array中(放在STL中會比較麻煩一點，這裡先以array做例子)，想要求array中所有數值和後求取平均

e.g.
// accum1.hpp
```cpp
template <typename T>
T accum(T const* beg, T const* end)
{
    T result = T{};    // 零初始化

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

// accum1.cpp
```cpp
int main()
{
    int nums[] = {1, 5, 8};
    std::cout << accum(nums, nums + 3) / 3 << std::endl;    // print 4
    
    char str[] = "ab";
    std::cout << accum(str, str + 2) / 2 << std::endl;    // print -30
}
```

範例中有個小細節就是使用零初始化，可使用該型別的default constructor。

int array的結果沒有甚麼問題，但是char array卻會回傳奇怪的結果，這是因為char只有1 byte，數值區間太小，a+b就會超過，故其結果為負數。

想解決這個問題，可以引進另一個template parameter作為result的型別，如下

e.g.
```cpp
accum<int>(str);    // int能不能省略？
```

但是那個int實在很礙眼，如果可以，使用者應該會希望回傳型別由開發者定義就好，因為這個沒這麼重要。

所以如果我們可以針對某些型別(像是這裡的char)，當看到這些型別時自動轉換為另一個型別，在這裡就是作為result的型別，就可以解決這個問題。這裡就會使用到2.8節的技巧

e.g.
// accumtraits2.hpp
```cpp
template <typename T>
struct AccumulationTraits;

template <>
struct AccumulationTraits<char>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <>
struct AccumulationTraits<int>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <typename T>
using AccumulationTraits_t = typename AccumulationTraits<T>::AccT;

template <typename T>
T accum(T const* beg, T const* end)
{
    AccumulationTraits_t<T> result = 0;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

這個寫法在有新型別加入時，只需要再加入新的AccumulateTraits的特化即可，且不只適用基本型別，非基本型別也一樣適用。

# 19.1.2 Valut Traits(數值式特徵)
上例展現了和template parameter無關的額外型別資訊中traits的功能，而traits並不僅限於型別，常數或其他類型的數值也一樣可以使用traits。

這裡就展現使用在數值方面的traits。我們可以想想前面的例子是否有哪些不完善之處
1. 一開始的例子(accumtraits1.hpp)我們有使用零初始化初始result，但是若型別並沒有定義預設建構子，就無法做零初始化。
2. 第二個例子(accumtraits2.hpp)中result都是從0開始，如果在某種型別中result不是從0開始，accum函式無法達到這個功能

這裡有使用到5.6的技巧，我們可以設定每種不同的traits其零初始化的值。

e.g.
// accumtraits3.hpp
```cpp
template <typename T>
struct AccumulationTraits;

template <>
struct AccumulationTraits<char>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <>
struct AccumulationTraits<int>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <typename T>
using AccumulationTraits_t = typename AccumulationTraits<T>::AccT;

template <typename T>
constexpr AccumulationTraits_t<T> AccumulationTraits_z = AccumulationTraits<T>::zero;

template <typename T>
T accum(T const* beg, T const* end)
{
    AccumulationTraits_t<T> result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

此節剩餘內容覺得有些瑣碎，就沒有多提，需要的話會再回來補充。

## 19.1.3 Parameterized Traits(參數化特徵)
這節不太懂跟上一節有甚麼不同，但還是說明一下。這節只是將決定result型別拉到template parameter區域決定而已

```cpp
template <typename T, typename AT = AccumulationTraits_t<T>>
T accum(T const* beg, T const* end)
{
    AT result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```