---
tags: template c++
---

template可以將型別參數化，而如果可以引進更多的template parameter，就可以為更多的面向進行客製化，不過如同我們不喜歡function有太多需要自行傳入的參數(對使用者來說是個負擔)一樣，使用者也不喜歡自己要定義太多的template parameter。

不過，如同函式可以使用預設引數，當使用者沒有定義時，會自動定義好這些預設引數，這些參數不會造成使用者的負擔，template也可以設定預設template parameter，可使用少數的template parameter就可以定義其餘的template parameter。

特徵萃取(traits)或是traits templates是一種C++編程裝置，很大程度的加強對於參數的管理，並且還可以適用在非template parameter的型別，本章會展示出traits有用之處並示範各種技巧。

以下內容的traits通常都會出現在STL中，所以實用性是無庸置疑的，但有時為了不要影響理解，會省略一些不重要的細節。

# 19.1 範例：求序列和
此節會實作求解序列中所有數值和的功能

## 19.1.1 Fixed Traits(固定式特徵)
假設數值都放在array中(放在STL中會比較麻煩一點，這裡先以array做例子)，想要求array中所有數值和後求取平均

e.g.
// accum1.hpp
```cpp
template <typename T>
T accum(T const* beg, T const* end)
{
    T result = T{};    // 零初始化

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

// accum1.cpp
```cpp
int main()
{
    int nums[] = {1, 5, 8};
    std::cout << accum(nums, nums + 3) / 3 << std::endl;    // print 4
    
    char str[] = "ab";
    std::cout << accum(str, str + 2) / 2 << std::endl;    // print -30
}
```

範例中有個小細節就是使用零初始化，可使用該型別的default constructor。

int array的結果沒有甚麼問題，但是char array卻會回傳奇怪的結果，這是因為char只有1 byte，數值區間太小，a+b就會超過，故其結果為負數。

想解決這個問題，可以引進另一個template parameter作為result的型別，如下

e.g.
```cpp
accum<int>(str);    // int能不能省略？
```

但是那個int實在很礙眼，如果可以，使用者應該會希望回傳型別由開發者定義就好，因為這個沒這麼重要。

所以如果我們可以針對某些型別(像是這裡的char)，當看到這些型別時自動轉換為另一個型別，在這裡就是作為result的型別，就可以解決這個問題。這裡就會使用到2.8節的技巧

e.g.
// accumtraits2.hpp
```cpp
template <typename T>
struct AccumulationTraits;

template <>
struct AccumulationTraits<char>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <>
struct AccumulationTraits<int>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <typename T>
using AccumulationTraits_t = typename AccumulationTraits<T>::AccT;

template <typename T>
T accum(T const* beg, T const* end)
{
    AccumulationTraits_t<T> result = 0;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

這個寫法在有新型別加入時，只需要再加入新的AccumulateTraits的特化即可，且不只適用基本型別，非基本型別也一樣適用。

# 19.1.2 Valut Traits(數值式特徵)
上例展現了和template parameter無關的額外型別資訊中traits的功能，而traits並不僅限於型別，常數或其他類型的數值也一樣可以使用traits。

這裡就展現使用在數值方面的traits。我們可以想想前面的例子是否有哪些不完善之處
1. 一開始的例子(accumtraits1.hpp)我們有使用零初始化初始result，但是若型別並沒有定義預設建構子，就無法做零初始化。
2. 第二個例子(accumtraits2.hpp)中result都是從0開始，如果在某種型別中result不是從0開始，accum函式無法達到這個功能

這裡有使用到5.6的技巧，我們可以設定每種不同的traits其零初始化的值。

e.g.
// accumtraits3.hpp
```cpp
template <typename T>
struct AccumulationTraits;

template <>
struct AccumulationTraits<char>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <>
struct AccumulationTraits<int>
{
    using AccT = int;
    static AccT const zero = 0;
};

template <typename T>
using AccumulationTraits_t = typename AccumulationTraits<T>::AccT;

template <typename T>
constexpr AccumulationTraits_t<T> AccumulationTraits_z = AccumulationTraits<T>::zero;

template <typename T>
T accum(T const* beg, T const* end)
{
    AccumulationTraits_t<T> result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

此節剩餘內容覺得有些瑣碎，就沒有多提，需要的話會再回來補充。

## 19.1.3 Parameterized Traits(參數化特徵)
這節將決定result型別拉到template parameter區域決定，若是往後其他使用者有想要使用的traits形式，可以輸入template paramteter更改，不過，大部分情況都還是使用預設的traits。

```cpp
template <typename T, typename AT = AccumulationTraits_t<T>>
T accum(T const* beg, T const* end)
{
    AT result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

# 19.2 Traits vs. Policies和Policy Classes
而accm(累計)可以不單能做加總這件事，若把加總視為一個"策略"(policy)，也就是
```cpp
result += *it;
```
這一個動作，我們可以使用不同的策略來達到不同的功能。

若將policy引進上例中，變動如下<br>
e.g.
// sumpolicy1.hpp
```cpp
class SumPolicy
{
  public:
    template <typename T1, typename T2>
    static void accumulate(T1& total, T2 const& value)
    {
        total += value;
    }
};
```

// accum6.hpp
```cpp
#include "accumtraits3.hpp"
#include "sumpolicy1.hpp"
template <typename T, typename Policy = SumPolicy, typename AT = AccumulationTraits_t<T>>
T accum(T const* beg, T const* end)
{
    AT result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        Policy::accumulate(result, *it);

    return result;
}
```

若想要代換成另外一種policy，這裡的例子是改成累乘，實作如下<br>
e.g.
// multiplepolicy1.hpp
```cpp
class MultiplePolicy
{
  public:
    template <typename T1, typename T2>
    static void accumulate(T1& total, T2 const& value)
    {
        total *= value;
    }
};
```

此時就會更改policy
```cpp
int main()
{
    int nums[] = {1, 2, 3};
    std::cout << accum<int, MultiplePolicy>(nums, nums + 3) << std::endl;
}
```

不過注意的是，由於初始值仍然是0，故累乘後結果仍為0

## 19.2.2 Member Template vs. Template Template Parameters
除了以上member templates的做法，也可以將該class直接設成class template，不過泛型使用時就需要使用template template parameter的技巧。

e.g.
// sumpolicy2.hpp
```cpp
template <typename T1, typename T2>
class SumPolicy
{
  public:
    static void accumulate(T1& total, T2 const& value)
    {
        total += value;
    }
};
```

// accum7.hpp
```cpp
template <typename T, 
        template <typename, typename> typename Policy = SumPolicy, 
        typename AT = AccumulationTraits_t<T>>
T accum(T const* beg, T const* end)
{
    AT result = AccumulationTraits_z<T>;

    for (auto it = beg; it != end; ++it)
        Policy<AT, T>::accumulate(result, *it);

    return result;
}
```

而使用template template parameter有個好處，那就是class明確的依賴template parameter，可以根據template parameter決定自己想要做的事情。但是同時也會讓policy class必須寫成template形式，template參數設定時必須完整的標示其template parameter(像是上例的template <typename, typename>)。

## 19.2.3 將多個policies或traits互相結合
一般而言，會將template parameter根據容易被選擇使用的頻率做排序，越常使用到的就放在越前面，越少使用到的(幾乎都是使用預設值)的就放在越後面，像是上例，Policy更改的頻率比AccumulationTriats_t還要頻繁，所以放在比較前方。
通常，policy更改的頻率會比traits還高，所以通常policy都會在traits前方。

## 以泛用迭代器進行累計
前面的例子都只能適用於一般的array，STL的容器都無法使用，以下示範更泛型的寫法。

e.g.
```cpp
template <typename IT>
auto accum(IT beg, IT end)
{
    using VT = typename std::iterator_traits<IT>::value_type;

    VT result = VT{};
    for (auto it = beg; it != end; ++it)
        result += *it;

    return result;
}
```

可以看到裡面的關鍵的是std::iterator_traits，其除了可以對STL的iterator做處理，也令為指標做偏特化使其可以像iterator一般做使用

```cpp
namespace std
{
    template <typename T>
    struct iterator_traits<T*>
    {
        ...
        using value_type = T;
        using pointer    = T*;
        ...
    }
}
```

不過由於我們使用了另一種型別(iterator)，所以如果需要traits推導累計值行別，還需要另外做traits。

# 19.3 Type Function
傳統上function傳入引數後，會回傳另一個數值作為結果，這種function可以定義為value functions，但若是根據不同的型別，可以輸出另一種型別或是常數，這裡稱為type functions

這裡簡單舉一個type function的例子，可以回傳任意型別的byte數(其實就是sizeof()的功能，只是把它包裝起來而已)

e.g.
```cpp
template <typename T>
struct TypeSize
{
    static std::size_t const value = sizeof(T);
};

int main()
{
    std::cout << TypeSize<double>::value << std::endl;
}
```

這裡輸入一個型別，會回傳其型別的大小，就是type functions的功能，並且，TypeSize<T>是一個型別，所以其可以作為class template parameter傳遞，TypeSize也可以是一個template template parameter。

## 19.3.1 決定元素型別
如果是需要傳入型別後回傳型別，一個常用的例子就是回傳容器的元素型別，像是std::vector、std::list甚至是array，而這件事可以用偏特化達成

e.g.<br>
// elementtype.hpp
```cpp
template <typename T>
struct ElementType;

template <typename T>
struct ElementType<std::vector<T>>
{
    using type = T;  
};

template <typename T>
struct ElementType<std::list<T>>
{
    using type = T;
};

template <typename T, std::size_t N>
struct ElementType<T[N]>
{
    using type = T;
};

template <typename T>
struct ElementType<T[]>
{
    using typen = T;
};
```

之後就可以以一個函式包裝讓使用者使用<br>
// elementtype.cpp
```cpp
#include "elementtype.hpp"

template <typename T>
void printElementType(T const& elems)
{
    std::cout << typeid(typename ElementType<T>::Type).name() << std::endl;
}

int main()
{
    std::vector<int> a;
    printElementType(a);
}
```

而透過這種偏特化的方式，我們只需要知道各個type functions都具有成員型別type描述其元素型別，不需要知道type functions其他實作細節。而許多STL的容器都還有value_type這個成員型別，所以若是要寫出一個type functions使其回傳這些容器的型別，可以更精簡的如下例表示，就不需要實作所有的偏特化版本

e.g.
```cpp
template <typename Container>
struct ElementType
{
    using Type = Container::value_type;
}
```

有了STL容器的例子，我們可以知道如果在設計容器時能夠直接將其元素型別設為其成員型別，可以使得泛型程式更方便使用。

e.g.
```cpp
template <typename T1, typename T2, ...>
class Container
{
  ...
  public:
    using Type1 = T1;
    using Type2 = T2;
    ...
};
```

說了這麼多，來看一下一個實際會用到type functions的例子，加總所有的元素回傳其元素總和

e.g.
```cpp
template <typename Container>
struct ElementType
{
    using Type = typename Container::value_type;
};

template <typename Container>
typename ElementType<Container>::Type sumOfElement(Container const& c)
{
    return accum(c.begin(), c.end());
}

int main()
{
    std::vector<int> a{1, 2, 3};
    std::cout << sumOfElement(a) << std::endl;
}
```

關鍵就是在
```cpp
typename ElementType<Container>::Type 
```

這個回傳值型別，而其實這也只是展示用，其實用auto就行了

e.g.
```cpp
template <typename Container>
struct ElementType
{
    using Type = typename Container::value_type;
};

template <typename Container>
//typename ElementType<Container>::Type sumOfElement(Container const& c)
auto sumOfElement(Container const& c)
{
    return accum(c.begin(), c.end());
}

int main()
{
    std::vector<int> a{1, 2, 3};
    std::cout << sumOfElement(a) << std::endl;
}
```

而上例中的ElementType又可以稱做traits class，其用來存取容器型別C中的traits。

另外，當然，討厭使用typename的人一定會想用別名模板簡化，當然沒問題

e.g.
```cpp
template <typename T>
using ElementType_t = ElementType<T>::type;
```

就可以更簡化上面的例子

e.g.
```cpp
template <typename Container>
ElementType_t<Container> sumOfElement(Container const& c)
{
    return accum(c.begin(), c.end());
}
```

## 19.3.2 轉化特徵(transformation traits)
除了根據型別有特殊的處理之外，traits也可以對型別做出修改，例如添加、刪除各種飾詞(e.g. reference、const、volatile)

### 去除reference
e.g.
```cpp
template <typename T>
struct RemoveReference;

template <typename T>
struct RemoveReference<T&>
{
    using Type = T;
};

template <typename T>
struct RemoveReference<T&&>
{
    using Type = T;
};

template <typename T>
using RemoveReference_t = RemoveReference<T>::type;
```

而其實STL中也有提供類似的功能，為std::remove_reference<>

### 添加reference
e.g.
```cpp
template <typename T>
struct AddLValueReference
{
    using Type = T&;
};

template <typename T>
using AddLValueReference_t<T> = AddLValueReference<T>::Type;

template <typename T>
struct AddRValueReference
{
    using Type = T&&;
};

template <typename T>
using AddRValueReference_t<T> = AddRValueReference<T>::Type;
```

稍微注意一下的是reference collasping規則，e.g. AddLValueReference_t<int&&>會回傳int&型別

不過，如果是添加飾詞，簡單的別名宣告就可以達到
e.g.
```cpp
template <typename T>
using AddLValueReference_t<T> = T&;

template <typename T>
using AddRValueReference_t<T> = T&&;
```

但需要注意的是，void在別名宣告的例子中是無法作為T傳入的。必須使用偏特化方式才能針對void做特殊處理

e.g.
```cpp
template <>
struct AddLValueReference<void>
{
    using Type = void;
};

template <>
struct AddRValueReference<void>
{
    using Type = void;
};

// ... 剩餘的void const、volatile、const volatile都是一樣的 
```

一樣的，添加lvalue及rvalue reference都在STL中有提供(std::add_lvalue_reference<T>、std::add_rvalue_reference<T>)

### 去除const
其實跟去除reference是一樣的
e.g.
```cpp
template <typename T>
struct RemoveConst
{
    using Type = T;
};

template <typename T>
struct RemoveConst<T const>
{
    using Typen = T;
};

template <typename T>
using RemoveConst_t = RemoveConst<T>::Type;
```

同樣的對於volatile是一樣的(就省略RemoceVolatile的版本了)，並且如果要去除所有飾詞，可以像以下使用<br>
e.g.
```cpp
template <typename T>
struct RemoveCV
{
    using Type = RemoveConst_t<RemoveVolatile_t<T>>;
};
```

或是像以下更簡潔的使用
e.g.
```cpp
template <typename T>
using RemoveCV_t = RemoveConst_t<RemoveVolatile_t<T>>;
```

### 退化
在函式中如果是以傳值方式傳遞引數，便會發生退化，會清除一切的修飾詞(reference、const、volatile)，並會將array轉換成指標，函式轉換成函式指標。這裡試圖做出退化的traits

首先，是array版本的退化，要將array退化成指標

e.g.
```cpp
template <typename T>
struct Decay : RemoveCV<T>{};

template <typename T>
struct Decay<T[]>
{
    using Type = T*;    
};

template <typename T, std::size_t N>
struct Decay<T[N]>
{
    using Type = T*;
};
```