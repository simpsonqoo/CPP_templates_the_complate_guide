---
tags: template c++
---

多型(polymorphism)在泛型程式中是一種單一泛型的表現方式，可以把類似的行為整合在一起，也是物件導向編程的基石，主要是透過繼承及virtual函式來達到目的。而這類的機制都需要在執行期才能夠完成，故又可以稱為動態多型(dynamic polymorphism)，通常在之前提到的多型都是指這種動態多型，而使用template一樣可以將類似的行為整合在一起，更可以在編譯期完成，故稱為靜態多型(static polymorphism)。本章便會比較這兩種多型的差異。

# 18.1 動態多型
一開始C++只透過virtual方式來支援多型，使用時會先將類似的功能先建立在抽象的父物件透過virtual宣告，並在子物件中定義。

一個常見的例子就是幾何形狀的管理，會先定義一個抽象的幾何物件GeoObj，而圓形、方形、三角形都會繼承此物件，而幾何物件都需要定義一些操作：重心位置、繪出兩個功能

![](https://i.imgur.com/iYwYYLc.png)

e.g.
```cpp
// dynahier.hpp
// 抽象父類別
#include "coordinate.hpp"

class GeoObj
{
  public:
    virtual void draw() = 0;
    virtual Coord centerOfGravity() = 0;
    ...
    ~GeoObj();
};

// cycle
class Cycle : public GeoObj
{
  public:
    void draw();
    void centerOfGravity();
    ...
    ~GeoObj;
};

// Line
class Line : public GeoObj
{
  public:
    void draw();
    void centerOfGravity();
    ...
    ~GeoObj;
};

// ... Triangle也是一樣的
```

使用情形如下<br>
e.g.
```cpp
// dynapoly.cpp
void myDraw(GeoObj const& obj)
{
    obj.draw();
}

Coord distance (GeoObj const& x1, GeoObj const& x2)
{
    return std::abs(x1.centerOfGravity() - x2.centerOfGravity());
}

void drawElement(std::vector<GeoObj*> const& elems)
{
    for (auto& elem : elems)
        elem -> draw();
}

int main()
{
    Line l;
    Circle c, c1, c2;
    
    myDraw(l);
    myDraw(c);
    distance(l, c);
    
    std::vector<GeoObj> coll{c1, c2};
    drawElement(coll);
}
```

在執行期尚未綁定前，並不會知道GeoObj實際是哪種物件，不過也因為這種特性，可以將類似的物件在執行期前都視為相同型別的物件，所以可以將cycle、line、triangle放入同一個容器內(書中稱為異質集合)，大概也是動態多型最吸引人的功能。

# 18.2 靜態多型
而template也可以用來實現多型，而實現方式並不會歸類共有的行為，而是每種不同的型別都有自己的定義。
<br><br>
![](https://i.imgur.com/oKbRm67.png)

除了沒有父物件之外，所有的實作也需要做修改<br>
e.g.
```cpp
template <typename T>
void myDraw(T const& obj)
{
    obj.draw();
}
```

比較一下和動態多型的差別，可以發現靜態多型並不像動態多型那樣來自父物件(基礎類別)，而是每個物件都可以看做是GeoObj的特化，更明顯的不同在於像是myDraw函式，使用動態多型就只會產生一個myDraw函式，根據不同的子物件呼叫不同的子物件成員函式，但是靜態多型則是每呼叫一個不同的物件，就會呼叫一個不同的MyDraw函式。

以下，直接改寫上例的動態多型成為靜態多型<br>
e.g.
```cpp
// statichier.hpp
#include "coordinate.hpp"

// cycle
class Cycle
{
  public:
    void draw();
    void centerOfGravity();
    ...
    ~GeoObj;
};

// Line
class Line
{
  public:
    void draw();
    void centerOfGravity();
    ...
    ~GeoObj;
};

// ... Triangle也是一樣的
```

使用情形如下<br>
e.g.
```cpp
// staticpoly.cpp
template <typename T>
void myDraw(T const& obj)
{
    obj.draw();
}

template <typename T1, typename T2>
Coord distance (T1 const& x1, T2 const& x2)
{
    return std::abs(x1.centerOfGravity() - x2.centerOfGravity());
}

template <typename GeoObj>
void drawElement(std::vector<GeoObj*> const& elems)
{
    for (auto& elem : elems)
        elem -> draw();
}

int main()
{
    Line l;
    Circle c, c1, c2;
    
    myDraw(l);
    myDraw(c);
    distance(l, c);
    
    // std::vector<GeoObj> coll{c1, c2};  error 不疼使用異質集合
    std::vector<Circle> elems;
    drawElement(elems);
}
```

靜態多型無法再像動態多型那樣使用異質集合，因為所有物件型別都會在編譯期決定，不過也因此對於集合內的物件做操作時，比較不會因為物件型別不同而產生錯誤，會有比較高的安全性。

# 18.3 動態多型v.s.靜態多型
