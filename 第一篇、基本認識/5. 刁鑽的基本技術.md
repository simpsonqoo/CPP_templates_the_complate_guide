# 5.1 typename關鍵字
typename適用來表明template裡某個識別字是型別，如以下用法

```cpp
template <typename T>
class MyClass
{
  public:
    ...
    void foo()
    {
        typename T::SubType* ptr;
    }
};
```

第一個typename就是表明template parameter，而第二個typename則是用來表明T::SubType是class T內的一個型別，所以ptr是T::SubType型別的指標。

```cpp
T::SubType* ptr
```
若不加上typename，則compiler會無法得知T::SubType是型別還是物件，若是型別，則代表目前宣告了型別為T::SubType*的指標，若是物件，則代表T::SubType物件乘上ptr物件這個行為。

所以為了避免這種情況發生，只要使用和template parameter有關的型別，都需要在前面加上typename。13.3.2會對細節做更深入的討論。

而第二種typename其中一個常用的應用就是在泛型程式碼中使用STL容器的iterator。

e.g.
// printcoll.hpp
```cpp
template <typename T>
void printcoll (T const& coll)
{
    typename T::iterator pos;
    typename T::iterator end(coll.end());

    for (pos = coll.begin(); pos != end; ++pos)
    {
        ...
    }
};
```

而在effective modern c++條款十三有提到C++11後所有STL容器幾乎都支援iterator及const_iterator

e.g.
```cpp
class stlContainer
{
  public:
    using iterator = ...;
    using const_iterator = ...;
    ...
};
```

所以如果需要const_iterator，也可以和使用iterator一樣的方式使用

e.g.
```cpp
typename T::const_iterator pos;
```

更多typename細節可見13.3.2