# 5.1 typename關鍵字
typename適用來表明template裡某個識別字是型別，如以下用法

```cpp
template <typename T>
class MyClass
{
  public:
    ...
    void foo()
    {
        typename T::SubType* ptr;
    }
};
```

第一個typename就是表明template parameter，而第二個typename則是用來表明T::SubType是class T內的一個型別，所以ptr是T::SubType型別的指標。

```cpp
T::SubType* ptr
```
若不加上typename，則compiler會無法得知T::SubType是型別還是物件，若是型別，則代表目前宣告了型別為T::SubType*的指標，若是物件，則代表T::SubType物件乘上ptr物件這個行為。

所以為了避免這種情況發生，只要使用和template parameter有關的型別，都需要在前面加上typename。13.3.2會對細節做更深入的討論。

而第二種typename其中一個常用的應用就是在泛型程式碼中使用STL容器的iterator。

e.g.
// printcoll.hpp
```cpp
template <typename T>
void printcoll (T const& coll)
{
    typename T::iterator pos;
    typename T::iterator end(coll.end());

    for (pos = coll.begin(); pos != end; ++pos)
    {
        ...
    }
};
```

而在effective modern c++條款十三有提到C++11後所有STL容器幾乎都支援iterator及const_iterator

e.g.
```cpp
class stlContainer
{
  public:
    using iterator = ...;
    using const_iterator = ...;
    ...
};
```

所以如果需要const_iterator，也可以和使用iterator一樣的方式使用

e.g.
```cpp
typename T::const_iterator pos;
```

更多typename細節可見13.3.2

# 5.2 以零初始化
對於基本型別(e.g. int, char...)來說，並沒有default constructor，所以任何為初始化的local變數其值都是未定義的。

## 函式
而若使用template技巧，未定義初始化的基本型別若沒有明確的賦值或初始化，其值就是未定義，但對於其他型別而言，都會有default constructor為其定義初始化。

```cpp
template <typename T>
void foo()
{
    T x;    // 若T為基本型別，則無法初始化，但T若不是基本型別，會初始化
}
```

所以，為了讓基本型別和其他型別行為保持一致，可以採取以下寫法

```cpp
template <typename T>
void foo()
{
    T x{};
}
```

但不知道為何，我使用的compiler若使用以下語法x是1

```cpp
template <typename T>
void foo()
{
    T x();
}
```

此時會採取以下任一行為
- 若有定義default constructor/初始列建構子，則會呼叫default constructor、初始列建構子
- 若沒有定義，則以零初始化(zero initialize)

而大括號初始化若需要轉型才能初始化，即使將constructor設為explicit也會做初始化

但是預設引數無法直接使用大括號初始化

e.g.
```cpp
template <typename T>
void foo(T x{})
{
    ...
}
```

必須以下列方式使用欲設引數
```cpp
template <typename T>
void foo(T x = T{})     // C++14後可以這樣使用
{
    ...
}
```

## class
對於class而言也是一樣的，對於所有的內建型別成員，如果沒有特別想要在初始化時定義其值，也建議使用大括號初始器來初始化

```cpp
template <typename T>
class MyClass
{
  private:
    T x;
  public:
    MyClass(): x{}{}
    ...
}
```

而使用小括號初始化也是沒問題的
```cpp
MyClass(): x(){}
```

但有種情況是只有大括號可做初始化的，那就是替非靜態物件在宣告時進行初始化

e.g.
```cpp
template <typename T>
class MyClass
{
  private:
    T x{};
    ...
}
```

# 5.3 使用this ->
如果有template class使用繼承，繼承自template class，在繼承的template class內使用任何物件x，C++的推導規則是"絕對不可能"使用base的template class內的物件x。

e.g.
```cpp
template <typename T>
class Base
{
  public:
    void print()
    {
        std::cout << "base" << std::endl;
    }
};

void print()
{
    std::cout << "global scope" << std::endl;
}

template <typename T>
class Derived : public Base<T>
{
  public:
    void foo()
    {
        print();
    }
};
```

呼叫Derived中的foo函式時，print()照書中所說應該會呼叫global scope的print()，但很奇怪的卻會呼叫Base中的print()。
書中13.4.2會深入探討這方面的議題，照書中所說，建議若base class為template class，若要呼叫所有base class中的物件時，都應該使用this ->或是Base<T>::。

# 5.4 用於原始陣列和String Literal的Templates
當template parameter在傳遞array或是string literal時，使用傳值和傳址會有不同的行為。傳址不會發生退化，傳值會發生退化，不同大小的array或是string literal在傳址是會被視為不同的型別，但若是傳值，都會退化為指標而使得不同大小的array或是string literal都會退化為指標而成為同一個型別。

如果要設計一個專門為array及string literal處理的function，可以設計如下，以下設計一個比較兩array或是string literal的function

```cpp
template <typename T, int SIZE1, int SIZE2>
bool less(T(&a)[SIZE1], T(&b)[SIZE2])
{
    for (int i = 0; i != std::min(SIZE1, SIZE2); ++i)
        if (a[i] != b[i])
           return a[i] < b[i];
    return SIZE1 < SIZE2;
}

less<const char, 5, 4>("1237", "345"); // 注意不能用char

int a1 = {1, 2, 3};
int a2 = {3, 4};
less<int, 4, 3>("1237", "345");
```

以下列出所有可以為array使用的重載方式

// array.hpp
```cpp
#include <iostream>

template <typename T>
struct MyClass;

template <typename T, std::size_t SZ>
struct MyClass<T[SZ]>;

template <typename T, std::size_t SZ>
struct MyClass<T(&)[SZ]>;

template <typename T>
struct MyClass<T[]>;

template <typename T>
struct MyClass<T(&)[]>;

template <typename T>
struct MyClass<T*>;
```

後面有給了一個各種使用方式呼叫的重載型別，覺得不難但很繁瑣，而且現在已經不太使用array了，這裡就直接跳過。

# 5.5 Member Templates
class的成員也可以是template，包括巢狀class及成員函式。這裡一樣用stack的例子來展示。一般而言，只有在template parameter一樣時才能為彼此賦值，如果template parameter不同，即使可以做隱士轉換就無法賦值，e.g. Stack<int>不能為Stack<double>賦值，為了讓可做隱式轉換的Stack可做賦值，以下會實作Stack的成員函式operator==。

```cpp
// stackdecl.hpp
template <typename T>
class Stack
{
  private:
    std::deque<T> elems;
  public:
    void push(T const&);
    void pop();
    T const& top() const{};

    bool empty() const
    {
        return elems.empty();
    }

    // 實作operator ==
    template <typename T2>
    Stack& operator== (Stack<T2> const&);
};
```

以上版本就可以接受兩個不同template parameter的Stack。以下是Stack::operator的實作

```cpp
template <typename T>
 template <typename T2>
Stack<T>& Stack<T>::operator== (Stack<T2> const& op2)
{
    Stack<T> temp(op2);

    elems.clear();
    while (!temp.empty())
    {
        elems.push_front(temp.top());
        temp.pop();
    }

    return *this;
}
```

這裡面有個很特別的語法