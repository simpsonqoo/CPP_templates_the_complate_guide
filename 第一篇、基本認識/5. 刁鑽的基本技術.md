# 5.1 typename關鍵字
typename適用來表明template裡某個識別字是型別，如以下用法

```cpp
template <typename T>
class MyClass
{
  public:
    ...
    void foo()
    {
        typename T::SubType* ptr;
    }
};
```

第一個typename就是表明template parameter，而第二個typename則是用來表明T::SubType是class T內的一個型別，所以ptr是T::SubType型別的指標。

```cpp
T::SubType* ptr
```
若不加上typename，則compiler會無法得知T::SubType是型別還是物件，若是型別，則代表目前宣告了型別為T::SubType*的指標，若是物件，則代表T::SubType物件乘上ptr物件這個行為。

所以為了避免這種情況發生，只要使用和template parameter有關的型別，都需要在前面加上typename。13.3.2會對細節做更深入的討論。

而第二種typename其中一個常用的應用就是在泛型程式碼中使用STL容器的iterator。

e.g.
// printcoll.hpp
```cpp
template <typename T>
void printcoll (T const& coll)
{
    typename T::iterator pos;
    typename T::iterator end(coll.end());

    for (pos = coll.begin(); pos != end; ++pos)
    {
        ...
    }
};
```

而在effective modern c++條款十三有提到C++11後所有STL容器幾乎都支援iterator及const_iterator

e.g.
```cpp
class stlContainer
{
  public:
    using iterator = ...;
    using const_iterator = ...;
    ...
};
```

所以如果需要const_iterator，也可以和使用iterator一樣的方式使用

e.g.
```cpp
typename T::const_iterator pos;
```

更多typename細節可見13.3.2

# 5.2 以零初始化
對於基本型別(e.g. int, char...)來說，並沒有default constructor，所以任何為初始化的local變數其值都是未定義的。

## 函式
而若使用template技巧，未定義初始化的基本型別若沒有明確的賦值或初始化，其值就是未定義，但對於其他型別而言，都會有default constructor為其定義初始化。

```cpp
template <typename T>
void foo()
{
    T x;    // 若T為基本型別，則無法初始化，但T若不是基本型別，會初始化
}
```

所以，為了讓基本型別和其他型別行為保持一致，可以採取以下寫法

```cpp
template <typename T>
void foo()
{
    T x{};
}
```

但不知道為何，我使用的compiler若使用以下語法x是1

```cpp
template <typename T>
void foo()
{
    T x();
}
```

此時會採取以下任一行為
- 若有定義default constructor/初始列建構子，則會呼叫default constructor、初始列建構子
- 若沒有定義，則以零初始化(zero initialize)

而大括號初始化若需要轉型才能初始化，即使將constructor設為explicit也會做初始化

但是預設引數無法直接使用大括號初始化

e.g.
```cpp
template <typename T>
void foo(T x{})
{
    ...
}
```

必須以下列方式使用欲設引數
```cpp
template <typename T>
void foo(T x = T{})     // C++14後可以這樣使用
{
    ...
}
```

## class
對於class而言也是一樣的，對於所有的內建型別成員，如果沒有特別想要在初始化時定義其值，也建議使用大括號初始器來初始化

```cpp
template <typename T>
class MyClass
{
  private:
    T x;
  public:
    MyClass(): x{}{}
    ...
}
```

而使用小括號初始化也是沒問題的
```cpp
MyClass(): x(){}
```

但有種情況是只有大括號可做初始化的，那就是替非靜態物件在宣告時進行初始化

e.g.
```cpp
template <typename T>
class MyClass
{
  private:
    T x{};
    ...
}
```