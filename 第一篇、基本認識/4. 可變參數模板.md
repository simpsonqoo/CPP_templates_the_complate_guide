從C++11開始，連template parameter的數量都可以不再固定。

# 4.1 Variadic Template
若template arguments的數量無上限，該template稱為variadic template。
## 4.2 例子
這裡實作一個可以印出所有可被std::cout印出的物件

e.g.
```cpp
void print()
{
}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << arg << ' ';
    print (restArgs...);
}

print (std::string("hello"), 1, 2.5);   //印出hello 1 2.5
```

args稱為function parameter pack(函式參數包)，呼叫print (std::string("hello"), 1, 2.5)時，print函式會被實體化為print<std::string, int, double>(std::string("hello"), 1, 2.5)，另外需注意的是print()版本需要在template版本之前被宣告。

### 執行步驟
1. print<std::string, int, double>(std::string("hello"), 1, 2.5)   
    - T為std::string
    - arg為"hello"
    - Types為int及double
    - restArgs為1及2.5
    呼叫print(2.5, 1)
2. print<int, double>(1, 2.5) 
    - T為int
    - arg為1
    - Types為double
    - restArgs為2.5
    呼叫print(1)
3. print<double>(2.5) 
    - T為double
    - arg為2.5
    - Types為空
    - restArgs為空
    呼叫print()
4. print<>()
    結束

## 重載Variadic及Nonvaridic Template
上例也可以如以下實作

```cpp
template <typename T>
void print(T arg)
{
    std::cout << arg << '\t';
}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << arg << '\t';
    print (restArgs...);
}
```

結果相同。而雖然print(1)在兩個function都是合法的，但是compiler會偏好使用沒有parameter pack的function。C.3.1會對這裡做更加詳細的說明。

## 4.1.3 sizeof...運算子
在C++11後可以使用sizeof...運算子，可以得知function parameter pack或是template parameter pack的參數數量。

e.g.
```cpp
void print()
{
}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << sizeof...(Types) << '\t';
    std::cout << sizeof...(restArgs) << std::endl;
    print (restArgs...);
}

print (std::string("hello"), 1, 2.5);   
// 得到
// 2 2
// 1 1
// 0 0
```