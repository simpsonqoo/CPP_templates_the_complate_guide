從C++11開始，連template parameter的數量都可以不再固定。

# 4.1 Variadic Template
若template arguments的數量無上限，該template稱為variadic template。
## 4.2 例子
這裡實作一個可以印出所有可被std::cout印出的物件

e.g.
```cpp
void print()
{
}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << arg << ' ';
    print (restArgs...);
}

print (std::string("hello"), 1, 2.5);   //印出hello 1 2.5
```

args稱為function parameter pack(函式參數包)，呼叫print (std::string("hello"), 1, 2.5)時，print函式會被實體化為print<std::string, int, double>(std::string("hello"), 1, 2.5)，另外需注意的是print()版本需要在template版本之前被宣告。

### 執行步驟
1. print<std::string, int, double>(std::string("hello"), 1, 2.5)   
    - T為std::string
    - arg為"hello"
    - Types為int及double
    - restArgs為1及2.5
    呼叫print(2.5, 1)
2. print<int, double>(1, 2.5) 
    - T為int
    - arg為1
    - Types為double
    - restArgs為2.5
    呼叫print(1)
3. print<double>(2.5) 
    - T為double
    - arg為2.5
    - Types為空
    - restArgs為空
    呼叫print()
4. print<>()
    結束

## 重載Variadic及Nonvaridic Template
上例也可以如以下實作

```cpp
template <typename T>
void print(T arg)
{
    std::cout << arg << '\t';
}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << arg << '\t';
    print (restArgs...);
}
```

結果相同。而雖然print(1)在兩個function都是合法的，但是compiler會偏好使用沒有parameter pack的function。C.3.1會對這裡做更加詳細的說明。

## 4.1.3 sizeof...運算子
在C++11後可以使用sizeof...運算子，可以得知function parameter pack或是template parameter pack的參數數量。

e.g.
```cpp
void print(){}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    std::cout << sizeof...(Types) << '\t';
    std::cout << sizeof...(restArgs) << std::endl;
    print (restArgs...);
}

print (std::string("hello"), 1, 2.5);   
// 得到
// 2 2
// 1 1
// 0 0
```

另外，如果我們想要終止條件在參數數量為1時，我們可能會想這樣實作

```cpp
void print(){}

template <typename T, typename... Types>
void print(T arg, Types... restArgs)
{
    if (sizeof...(Types) > 0)
    {
        std::cout << sizeof...(Types) << '\t';
        std::cout << sizeof...(restArgs) << std::endl;
        print (restArgs...);
    }
}
```

但是這樣做是不行的，因為在編譯期時，if的所有分支都會被實體化，而分支是否需要被呼叫，是執行期決定的事情，所以上例在編譯期時，到print()後就會一直不斷為print()做實體化且不會終止，導致編譯期錯誤。

而C++17後提供了編譯期條件運算(constexpr_if)，只要稍作改寫就能達到這樣的功能，在8.5節會有詳細的說明。