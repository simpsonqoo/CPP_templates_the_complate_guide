class也和function一樣能使多個參數定義成一個物件，container就是一個典型的例子，此章會以實作stack的方式說明類別模板的各個概念。

# 2.1 實作class template stack
首先，先簡單實作stack

```cpp
#include <vector>
#include <cassert>

template <typename T>
class Stack
{
  private:
    std::vector<T> elems;
  
  public:
    void push(T const& elem);
    void pop();
    T const& top() const;
    bool empty() const
    {
        return elems.empty();
    }
};

template <typename T>
void Stack<T>::push (T const& elem)
{
    elems.push_back(elem);
}

template <typename T>
void Stack<T>::pop ()
{
    assert(!elems.empty());
    elem.pop_back();
}

template <typename T>
T const& top () const
{
    assert(!elems.empty());
    return elems.back();
}
```

本章會著重在class template介面上，所以直接使用現成的std::vector，就不需實做其細節。

## 2.1.1 宣告class template
宣告方式和function template相同，需要宣告class前宣告template parameter

e.g.
```cpp
template <typename T>
class Stack
{
    ...
}
```

就像是一般container的用法一樣，每一個使用到該class處，除非其template parameter可被推導，否則都必須指明其template parameter型別。
而若是在class內部使用該class，如果沒有寫出template paramter型別，該參數就會和class使用的參數相同

e.g.
```cpp
template <typename T>
class Stack
{
    Stack (const Stack& );   // Stack& 自動被推導為Stack<T>
    // Stack (const Stack<T>&); 和上一指令同義
}
```

不過，如果是在class外部使用該class，無論是不是class的內部成員，都得定義好template parameter

e.g.
```cpp
template <typename T>
bool operator== (Stack<T> const& lhs, Stack<T> const& rhs);
```

而還有一個地方需要注意的，template class只能定義於global scope、namespace scope和class宣告式內，template class無法在任何的區域scope內宣告。

## 2.1.2 實作成員函式(push、pop及top)
若要定義一個class template中的member function，在定義時需要將其class中所有的型別修飾詞(像是Stack<T>)表示出來，以下以實作Stack中的push為例

e.g.
```cpp
template <typename T>
void Stack<T>::push (T const& elem)
{
    elems.push_back(elem);
}
```

若要實作pop，現今的std::stack的pop都不會回傳其刪除的物件，書中實作的是會回傳已刪除物件的版本，可能有時會有些危險，但如果暫時忽略這些危險，可以這樣實作

e.g.
```cpp
template <typename T>
T Stack<T>::pop ()
{
    assert(!elems.empty());
    T elem = elems.back();
    elems.pop_back();
    return elem;
}
```

還有top以及push

e.g.
```cpp
template <typename T>
T Stack<T>::top ()
{
    assert(!elems.empty());
    return elems.back();
}
```

而和一般class一樣，member function可以實作在class宣告式內，而該member function會自動被歸類為inline function。
```cpp
template <typename T>
class Stack
{
    void push (T const& elem)
    {
        elems.push_back(elem);
    }
};
```