class也和function一樣能使多個參數定義成一個物件，container就是一個典型的例子，此章會以實作stack的方式說明類別模板的各個概念。

# 2.1 實作class template stack
首先，先簡單實作stack

```cpp
#include <vector>
#include <cassert>

template <typename T>
class Stack
{
  private:
    std::vector<T> elems;
  
  public:
    void push(T const& elem);
    void pop();
    T const& top() const;
    bool empty() const
    {
        return elems.empty();
    }
};

template <typename T>
void Stack<T>::push (T const& elem)
{
    elems.push_back(elem);
}

template <typename T>
void Stack<T>::pop ()
{
    assert(!elems.empty());
    elems.pop_back();
}

template <typename T>
T const& Stack<T>::top () const
{
    assert(!elems.empty());
    return elems.back();
}
```

本章會著重在class template介面上，所以直接使用現成的std::vector，就不需實做其細節。

## 2.1.1 宣告class template
宣告方式和function template相同，需要宣告class前宣告template parameter

e.g.
```cpp
template <typename T>
class Stack
{
    ...
}
```

就像是一般container的用法一樣，每一個使用到該class處，除非其template parameter可被推導，否則都必須指明其template parameter型別。
而若是在class內部使用該class，如果沒有寫出template paramter型別，該參數就會和class使用的參數相同

e.g.
```cpp
template <typename T>
class Stack
{
    Stack (const Stack& );   // Stack& 自動被推導為Stack<T>
    // Stack (const Stack<T>&); 和上一指令同義
}
```

不過，如果是在class外部使用該class，無論是不是class的內部成員，都得定義好template parameter

e.g.
```cpp
template <typename T>
bool operator== (Stack<T> const& lhs, Stack<T> const& rhs);
```

而還有一個地方需要注意的，template class只能定義於global scope、namespace scope和class宣告式內，template class無法在任何的區域scope內宣告。

## 2.1.2 實作成員函式(push、pop及top)
若要定義一個class template中的member function，在定義時需要將其class中所有的型別修飾詞(像是Stack<T>)表示出來，以下以實作Stack中的push為例

e.g.
```cpp
template <typename T>
void Stack<T>::push (T const& elem)
{
    elems.push_back(elem);
}
```

若要實作pop，現今的std::stack的pop都不會回傳其刪除的物件，書中實作的是會回傳已刪除物件的版本，可能有時會有些危險，但如果暫時忽略這些危險，可以這樣實作

e.g.
```cpp
template <typename T>
T Stack<T>::pop ()
{
    assert(!elems.empty());
    T elem = elems.back();
    elems.pop_back();
    return elem;
}
```

還有top以及push

e.g.
```cpp
template <typename T>
T Stack<T>::top ()
{
    assert(!elems.empty());
    return elems.back();
}
```

而和一般class一樣，member function可以實作在class宣告式內，而該member function會自動被歸類為inline function。
```cpp
template <typename T>
class Stack
{
    void push (T const& elem)
    {
        elems.push_back(elem);
    }
};
```

# 2.2 使用Class Template Stack
C++11之前，只要需要使用class template物件，都必須要顯式標明所有的template參數，而在C++17之後，有些狀況無需標明(2.9節會提到)。

e.g.
```cpp
Stack<int> s1;
Stack<std::string> s2;
```
而雖然Stack有很多種不同的可能(T可能有很多種型別)，但只會為已呼叫的型別做實體化，以上例來說，只會實體化元素型別為int和std::string的Stack。

而class template的實體化中，只會實體化實際有使用的member function及物件

```cpp
// 使用s1的member function
s1.push(1);
auto i = s1.top();

// 使用s2的member function
s2.push(std::string("hi"));
auto str = s2.top();
s2.pop();
```

以上例為例，只會對s1的push、top及s2的push、top、pop做實體化。而若template class中有靜態成員，則會針對每種有使用到的template參數型別做實體化。

實體化後，template class就可以像一般的物件一樣被使用，無論是要加上const、volatile，亦或是要使用別名宣告

e.g.
```cpp
const Stack<int> s3;

using IntStack = Stack<int>;

IntStack is;
```

# 2.3 僅使用部分class template
實體化template class時，只會實體化實際有使用的member，所以即使某些template參數型別實體化後會有錯誤(無論是compiler error或式runtime error)，只要不要使用這些member就不會發生錯誤，因為這些member並沒有被實體化。

假設我們實作了一個印出Stack內所有物件的函式
```cpp
class Stack
{
    ...
    void operator<< (std::ostream& os) const
    {
        for (auto& elem : elems)
            os << elem << '\t';
        os << std::endl;
    }
}
```

若Stack<T>中的T型別是int，則使用printElement不會有問題，但如果T型別是std::vector<int>，就會產生compiler error，因為無法使用vector並不支援<<的語法。

但是如果不使用printElement，T型別是std::vector<int>是沒有問題的。

```cpp
Stack<int> s4;
s4.push(1);
s4.print(std::cout);   // ok

Stack<std::vector<int>> s5;
s5.push(2);     // 截至目前為止都沒有問題
s5.print(std::cout);  // compiler error
```

所以，即使某一個T型別會產生錯誤，只要不要使用，就不會有問題！

## 2.3.1 Concept
而當compiler error發生時，comipler會將建構物件開始直到錯誤發生的訊息都顯示出來，常常都是落落長難以辨別是甚麼問題，所以加上適當的檢查經常是必要的。以下是檢查物件中的member有沒有定義預設建構子(default construvtor)。

```cpp
template <typename T>
class C
{
    static_assert(std::is_default_constrctible<T>::value,
        "classs C requires default constructible element!");
};
```

在19.6.3中還會對這個問題做詳細的討論。

# 2.4 Friend
