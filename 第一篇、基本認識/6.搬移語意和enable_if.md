---
tags: template c++
---

# 6.1 完美轉發
完美轉發指的是無論傳入的是lvalue or rvalue、const or non-const、reference or value，都可以順利地傳遞且型別都不會變

以下舉個簡單沒有實作template的例子，完美轉發函式f至函式g，的參數來體驗一下轉發是甚麼

e.g.
// move1.hpp
```cpp
#include <iostream>

void g(int& a)
{
    std::cout << "non-const lvalue reference type" << std::endl;
}

void g(int const& a)
{
    std::cout << "const lvalue reference type" << std::endl;
}

void g(int&& a)
{
    std::cout << "rvalue reference type" << std::endl;
}

void f(int& a)
{
    g(a);    // 呼叫g(int&)
}

void f(int const& a)
{
    g(a);    // 呼叫g(int const&)
}

void f(int&& a)
{
    g(std::move(a));    // 呼叫g(int&&)
}

int main()
{
    int x{1};
    int const y{2};
    f(x);
    f(y);
    f(int(1));
}
```

output:
```
non-const lvalue reference type
const lvalue reference type
rvalue reference type
```

需要注意的是第三個版本(void f(int&& a))，由於movable物件(以rvalue reference型別表示)並沒辦法作傳遞，當其出現在陳述句時，其就會自動轉型為non-const lvalue，若不加上std::move()，其行為就會等同於第一個f版本(void f(int& a))。

e.g.
```cpp
void f(int&& a)
{
    g(a);    // 呼叫g(int&)
}
```

而template的特性就是能寫出一個能產生各種版本的物件或function。所以，同樣的我們也想寫出一個能適用於各種型別的f，並將其引述傳給g。雖然reference之前有提供會保留型別，但卻沒辦法保留movable物件。

```cpp
template <typename T>
void f(T& val)
{
    g(val);    // 無論T式什麼型別，都不可能呼叫g(int&&)
}
```

所以C++11提供了完美轉發(perfect forwarding)語意，表示如下

```cpp
template <typename T>
void f(T&& val)
{
    g(std::forward<T>(val));
}
```

和std::move()不同，std::move()保證會使用搬移語意使得物件成為movable物件，但std::forward並不會保證使用搬移語意，只會根據型別T的不同"嘗試"使用搬移語意。

而另外需要注意的是，T&&和int&&是完全不一樣的
- int&&為rvalue reference，ravlue reference可以是純右值、xvalue(可透過std::move()傳遞的物件)，一定可以使用搬移語意
- T&&為forwarding reference(轉發參考)，val可以是const、non-const或是movable物件。

而使用forwarding reference有個限制，就是不能是依賴於template parameter的型別，就是前面說過需要加上typename的型別(e.g. typename std::vector<T>::iterator&&)，這樣只會被視為rvalue reference，也就是第一種狀況

所以，我們可以修改一下f並使用完美轉發達成泛型的目的
```cpp
#include <iostream>

void g(int& a)
{
    std::cout << "non-const lvalue reference type" << std::endl;
}

void g(int const& a)
{
    std::cout << "const lvalue reference type" << std::endl;
}

void g(int&& a)
{
    std::cout << "rvalue reference type" << std::endl;
}

template <typename T>
void f(T&& a)
{
    g(std::forward<T>(a));
}

int main()
{
    int x{1};
    int const y{2};
    f(x);
    f(y);
    f(int(1));
}
```

執行結果和第一個例子同。
