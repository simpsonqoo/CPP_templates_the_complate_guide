template parameter除了可以是型別之外，也可以是數值，如同型別型態的template parameter一樣，在定義時可以暫時保留部分的程式碼，等到實際使用時才會呼叫其實際的版本。

# 3.1 Nontype Class Template Parameters
本章一樣使用Stack做為例子，而除了使用上章使用的std::vector之外，使用固定大小的std::array也是個不錯的做法，可以避免管理記憶體時的成本。不過std::array的大小需要提前給定，如果給太大會浪費，給太小又可能會不夠用，一個比較好的實作方式是交由使用者自行決定，所以可以使用數值型式的template parameter。

e.g.
// stacknontype.hpp
```cpp
template <typename T, std::size_t Maxsize>
class Stack
{
  private:
    std::array<T, Maxsize> elems;
    std::size_t numElements;

  public:
    Stack();
    void push(T const& elem);
    void pop();
    T const& top() const;

    bool empty() const
    {
        return numElements == 0;
    }

    std::size_t size() const
    {
        return numElements; 
    }
};

template <typename T, std::size_t Maxsize>
Stack<T, Maxsize>::Stack() : numElements(0){}

template <typename T, std::size_t Maxsize>
void Stack<T, Maxsize>::push(T const& elem)
{
    assert(numElements < Maxsize);
    elems[numElements] = elem;
    ++numElements;
}

template <typename T, std::size_t Maxsize>
void Stack<T, Maxsize>::pop()
{
    assert(numElements != 0);
    --numElements;
}

template <typename T, std::size_t Maxsize>
T const& Stack<T, Maxsize>::top() const
{
    assert(numElements != 0);
    return elems[numElements - 1];
}
```

// stacknontype.cpp
```cpp
Stack<int, 5> s1;
s1.push(2);
s1.pop();

Stack<std::string, 10> s2;
s2.push("hello");
s2.top();
```

另外注意，不像是std::vector，只要Maxsize不同的std::array就是不同的型別，無法互相賦值或轉型。

而數值型態的template parameter也可以預設引數

e.g.
```cpp
template <typename T, std::size_t Maxsize = 100>
class Stack
{
    ...
};
```

不過在這裡使用預設數值並不是個好做法，通常預設值會設成大部分通用的值，但是設成100明顯就不是通用的Stack大小，所以在這裡還是給使用者自行定義會比較好。

# 3.2 Nontype Function Template Parameters
當然，也有nontype的template function，如同一般的參數一樣可以被function所使用。例如想要為std::vector中每個元素增加一個固定值，可以實作addValue函式來達成

e.g.
```cpp
template <int Val, typename T>
T addValue(T x)
{
    return x + Val;
}

std::vector<int> vec{1, 2, 3};
std::transform (vec.begin(), vec.end(), addVal<3, int>)); //執行後vec為{4, 5, 6}
```

這裡使用時我們必須明確的標明每一個template parameter，但是明顯的addVal中第二個template parameter(int)是不必要的，應該是可以被推導出來的，所以可以將函式改為

```cpp
template <auto Val, typename T = decltype(Val)>
T addValue(T x)
{
    return x + Val;
}

std::transform(vec.begin(), vec.end(), vec.begin(), addValue<3>);
```

nontype template parameter也可以使用auto，讓compiler自動推導型別。

