# 1.1 初識Function Template
&emsp;&emsp;Function Template可以讓單一函式適用不同的型別行為，表現上看起來除了未被決定的物件型別外，只是一個普通的函式。而那些未被決定型別其實是被參數化了，就如同函數傳入之引數一樣。

## 1.1.1 定義template
以下是一個簡單的範例，其函式會回傳兩數中較大的數。

e.g.
```cpp
// max.hpp
template <typename T>
T max(T a, T b)
{
    if (a > b)
        return a;
    return b;
}

max(1, 2);  // 回傳2
```

此例中a和b(參數)之型別都是未定的，而其型別是以參數(template parameter)形式表示。

template parameter必須用以下的語法先宣告
```cpp
template<一列以逗號區別的參數>

template<typename t1, typename t2, ...>
```
template parameter可以使用任何名字，但一般習慣使用的template parameter是T(type)。在使用template函式時可以使用各種型別，只要保證其在template函式中的各種運算皆可以被使用即可。在上述例子中，要使用max時，必須保證傳入物件之型別是可以做>比較的。而還有一點比較細節的是，若要使用某物件型別作為T，必須保證該型別是可複製的(具有copy constructor)，但是在C++17後就沒有該項限制的，可以直接傳入lvalue而不使用copy constructor。

而由於歷史因素，typename也可以以class取代，其功能完全沒有差異。但是使用typename比較可以直觀的說明其並不僅限於使用class型別，故還是推薦使用typename來定義template parameter。

e.g.
```cpp
//和上述例子行為相同
template <class T>
T max(T a, T b)
{
    if (a > b)
        return a;
    return b;
}


```

## 1.1.2 使用Template
以下是簡單使用template的範例

e.g.
```cpp
// max.cpp
#include <iostream>
#include <string>
#include "max.hpp"

int main()
{
    int a = 10;
    std::cout << ::max(20, 10) << std::endl;

    double b = 5.5;
    double c = 2.4;
    std::cout << ::max(b, c) << std::endl;

    std::string d{"ex"};
    std::string e{"example"};
    std::cout << ::max(d, e) << std::endl;
}
```

output:
```
20
5.5
example
```

三次使用max函式時使用三種不同的引數，第一次呼叫時T推導為int，第二次是double，第三次是std::stirng。

> note:
有人使用STL時怕麻煩，會添加using namespace std;這一行，但是如果添加後直接使用max函數，會和STL中的max函數有所衝突，會使得compiler不知道要使用哪個max函式。這裡為了要和STL中的max函式有所區隔，使用::max，代表我們要使用的是在全域中max函數。

而實際template在編譯時並不是將max函式變成是一個萬用的程式碼，而是根據不同T的推導型別產生出不同的版本，例如，上例中第一次呼叫max函式時，就會產生出和下方意義一樣的程式碼

```cpp
int max(int a, int b)
{
    if (a > b)
        return a;
    return b; 
}
```

而將T推導為實際型別的過程，稱為實體化(instantiation)，此時會產生template實體(instance)。

小小需要留意的是，void也可以是T推導的型別。
e.g.
```cpp
template <typename T>
void f(T);

void* vp = nullptr;
f(vp);  // T推導為void*，呼叫void f(void*)
```

## 1.1.3 兩段式轉譯
當compiler編譯階段時，會分為兩個階段，只要其中一個階段有錯誤，就會導致compiler error。
1. 尚未實體化的定義時期(definition time)
此階段會忽略所有的template parameter，會檢查語法、和template parameter無關的物件型別...
2. 實體化時期(instantiation time)
此階段會再檢查該段template程式碼，確認template parameter型別後重新檢驗一次。

e.g.
```cpp
template <typename T>
void foo(T t)
{
    undeclared();   // 定義期檢查，如果沒有undeclared或是其內部程式碼有誤，則再定義期就會發生compiler error
    undeclared(t);  // 實體化時期才會檢查undeclared(T)是否會發生compiler error
    sizeof(int);
    sizeof(T);  //實體化時期才會檢查
}
```