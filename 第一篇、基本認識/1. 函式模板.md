# 1.1 初識Function Template
&emsp;&emsp;Function Template可以讓單一函式適用不同的型別行為，表現上看起來除了未被決定的物件型別外，只是一個普通的函式。而那些未被決定型別其實是被參數化了，就如同函數傳入之引數一樣。

## 1.1.1 定義template
以下是一個簡單的範例，其函式會回傳兩數中較大的數。

e.g.
```cpp
template <typename T>
T max(T a, T b)
{
    if (a > b)
        return a;
    else
        return b;
}

max(1, 2);  // 回傳2
```

此例中a和b(參數)之型別都是未定的，而其型別是以參數(template parameter)形式表示。

template parameter必須用以下的語法先宣告
```cpp
template<一列以逗號區別的參數>

template<typename t1, typename t2, ...>
```
template parameter可以使用任何名字，但一般習慣使用的template parameter是T(type)。在使用template函式時可以使用各種型別，只要保證其在template函式中的各種運算皆可以被使用即可。在上述例子中，要使用max時，必須保證傳入物件之型別是可以做>比較的。而還有一點比較細節的是，若要使用某物件型別作為T，必須保證該型別是可複製的(具有copy constructor)，但是在C++17後就沒有該項限制的，可以直接傳入lvalue而不使用copy constructor。

而由於歷史因素，typename也可以以class取代，其功能完全沒有差異。但是使用typename比較可以直觀的說明其並不僅限於使用class型別，故還是推薦使用typename來定義template parameter。

e.g.
```cpp
//和上述例子行為相同
template <class T>
T max(T a, T b)
{
    if (a > b)
        return a;
    else
        return b;
}


```

## 1.1.2 使用Template