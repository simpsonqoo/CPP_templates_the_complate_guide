---
tags: template c++
---

還記得之前有提過建議以傳值代替傳址，本章就試圖用各種角度為其建議提出論述

而傳址直到C++11後又多了選擇，共有下列幾種
- X const&: 常數左值參考
- X&: 左值參考
- X&&: 右值參考

# lvalue v.s. rvalue v.s. catogory
[參考網站](https://www.yuanguohuo.com/2018/05/24/cpp11-value-types/)
在C++11後，傳統的lvalue和rvlaue已經不夠用了，故又另外新增了幾種類型
![](https://i.imgur.com/L6ONsw9.png)

以分類來說，以下列規則來分類
- 是否有身分(名字)
- 是否可搬移

所以排列組合後會有下列四種
1. 有身分、可搬移
2. 有身分、不可搬移
3. 無身分、可搬移
4. 無身分、不可搬移

最後一種是不存在的，而傳統的lvalue、rvalue分類的依據在C++11後就是"可否搬移"，故1,3為傳統的rvalue，2為lvalue

而若有身分，其實是C++11以前被定義的lvalue，這裡就會被稱為廣義的lvalue -> glvalue(generalized lvalue)

而有身分、可搬移，在這裡就被稱為xvalue，常見於使用std::move後的物件

無身分，可搬移就是傳統認為的rvalue，C++11後稱為prvalue(pure rvalue)

熟悉了各種類型後，就可以進入本章了

# 以值傳遞
原則上，引數以值傳遞時都會呼叫copy constructor複製該引數

e.g.
```cpp
template <typename T>
void foo(T arg)
{} 

foo(1);    //會複製新的i
```

不過，並不是任何狀況使用值傳遞都會有複製的行為，若傳入的是prvalue，則compiler會自動優化，不會呼叫copy constructor。

e.g.
```cpp
int i = 1;
foo(i);    // 會呼叫copy constructor
foo(std::string("hi"));
foo(retrunint());    // returnint為一回傳int的函式
foo(std::move(i));    // 呼叫move constructor
```

所以，以值傳遞只有在傳遞lvalue時才會呼叫copy constructor，其餘都不會呼叫copy constructor，但是不幸的是，傳遞lvalue是很常見的行為。

## 傳值退化
傳值會移除傳入引數的const及volatile，而array會退化為指標。
- 好處是不同大小的array都會退化為指標，可以對其有一致的行為。
- 但是在function內，當看到原始指標時，並不會知道其實際真的是指標或是array。

